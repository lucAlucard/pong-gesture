{"name":"Pong-gesture","tagline":"the \"pong\" game but with gestures controls","body":"# Como fazer um jogo de Pong com realidade aumentada usando tracking.js\r\n### Grupo: Lucas Rogério, Lucas Rodrigues\r\n\r\nNesse tutorial iremos aprender a criar um jogo simples de pong usando uma biblioteca de realidade aumentada tracking.js, portanto, baixe a mesma no link: “http://trackingjs.com/” para que possamos  criar o game\r\nPrimeiro iremos criar o documento HTML\r\n```\r\n<!doctype html>\r\n<html>\r\n<head>\r\n\t<meta charset=\"UTF-8\">\r\n\t<title>Pong Gesture</title>\r\n<!--SUBSTITUA AQUI O LOCAL ONDE VOCÊ COLOCOU AS BIBLITECAS DO TRACKING.JS-->\r\n\t<script src=\"../js/build/tracking-min.js\"></script>\r\n\t<script src=\"../../dat-gui/build/dat.gui.min.js\"></script>\r\n\t<script src=\"../js/assets/stats.min.js\"></script>\r\n\t<script src=\"../js/assets/color_camera_gui.js\"></script>\r\n\t<!-- Basic styling, centering the canvas -->\t\r\n\t<style>\r\n\tcanvas {\r\n    \tdisplay: block;\r\n    \tposition: absolute;\r\n    \tmargin: auto;\r\n   \t top: 0;\r\n    \tbottom: 0;\r\n    \tleft: 0;\r\n    \tright: 0;\r\n\t}\r\n\t</style>\r\n</head>\r\n<body>\r\n\t<div>\r\n    \t<div>\r\n        \t<video id=\"video\" width=\"300\" height=\"225\" preload autoplay loop muted controls></video>\r\n        \t<canvas id=\"canvas\" width=\"300\" height=\"225\"></canvas>\r\n    \t</div>\r\n\t</div>\r\n\t<script>\r\n```\r\nMas, vamos agora aprender um pouco de javascript.\r\nPrimeiro, vamos definir nosso campo onde irá acontecer as disputas de pong. Para isso, vamos definir os limites da nossa tela e guarda-los em duas variáveis, vamos chama-las respectivamente de Largura e Altura. Para capturar a largura vamos usar o comando window.innerWidth e guardá-lo na variável Largura e o para capturar a altura vamos usar o comando window.innerHeight e guardá-lo na variável ALTURA. Ficando com o código dessa maneira:\r\n```\r\nvar\r\n\tLARGURA  = window.innerWidth,\r\n\tALTURA = window.innerHeight,\r\n    canvas,\r\n\tctx\r\n```\r\n\r\nAgora, vamos definir a função principal do nosso projeto que será a nossa main, que será responsável por fazer a chamada de todas as  outras funções.\r\n```\r\nfunction main() {\r\n}\r\n``` \r\n\r\nAgora com nossas variáveis com o tamanho da tela definidas vamos usar o comando createElement(\"canvas \") para criar imagens por código. E criaremos uma variável ctx (abreviação de contexto) usando o comando canvas.getContext(\"2D \" ) para informar que esse elemento irá ser 2D (sim, o canvas pode criar elementos 3D!) e para não precisarmos ficar digitando toda hora canvas.getContext(\"2D\").alguma_coisa. Essa variável será responsável por desenhar todos os elementos do jogo, como as paletas, campo e a bola. Por fim iremos adicionar essa variável ao corpo do nosso documento HTML com o comando document.body.appendChild(canvas). Então nosso código ficará dessa forma:\r\n```\r\nfunction main(){\r\n\tcanvas = document.createElement(\"canvas\")\r\n\tcanvas.width = LARGURA\r\n\tcanvas.height = ALTURA\r\n\tctx = canvas.getContext(\"2d\");\r\n\tdocument.body.appendChild(canvas);\r\n}\r\n```\r\n\r\nVamos criar uma função responsável por fazer todos os desenhos, vamos chama-la de “desenhar”.\r\n```\r\n\tfunction desenhar() {\r\n\r\n    \t//Desenhando o retângulo na tela a partir da posição x = 0, y = 0  do tamanho dos limites da minha tela (que eu havia capturado anteriormente na variável)\r\n    \tctx.fillRect(0, 0, LARGURA, ALTURA);\r\n    \t//entender melhor como funciona...\r\n    \tctx.save();\r\n    \t//definindo a cor dos meus elementos em hexa decimal, sendo fff = branco.  E cada caracter é respectivamente responsável pela cor Vermelho, Verde e Azul.\r\n    \tctx.fillStyle = \"#fff\";\r\n   }\r\n```\r\n\r\nAgora vamos fazer a linha que delimita os lados dos jogadores. Então, dentro da função “desenhar”  coloque:\r\n\r\n```\r\n    \t//Definindo uma variável para dizer qual o tamanho da largura da linha\r\n    \tvar larguraLinha = 4;\r\n    \t//Definindo outra variável para dizer qual será a posição X da linha, que no caso, como eu quero colocar no meio do campo, seria a “largura do campo” menos a “largura da linha” divido por 2\r\n    \tvar x = (LARGURA - larguraLinha) / 2;\r\n    \t//Definindo outra variável para dizer a posição Y a partir de onde será desenhado o tracejado\r\n    \tvar y = 0;\r\n    \t//aqui estamos definindo outra variável para dizer qual será a distância entre um traço e outro\r\n    \tvar passo = ALTURA/20;\r\n        \t//\"x\" define a posição X do retângulo, y diz a posição Y do retângulo, estamos somando com passo / 4 pois queremos que ele fique no começo da tela com um espaço de 1/4 sem estar pintado. A \"larguraLinha\" diz a largura do retângulo, e o passo / 2 é que queremos que o tamanho vertical dele seja igual a metade (1/2) do passo.\r\n            ctx.fillRect(x, larguraLinha + passo / 4, larguraLinha, passo / 2);\r\n        \ty += passo;\r\n    \t}\r\n    \t//entender melhor como funciona essa bagaçahttps://github.com/lucasRogerioOliveira/pong-gesture/generated_pages/new#...\r\n    \tctx.restore();\r\n}\r\n```\r\n\r\nSe tudo até agora deu certo o resultado esperado deve ser isso:\r\n\r\n![campo inicial](http://s30.postimg.org/u2fszq8dd/campo_1.png)\r\n\r\nAgora com nosso campo feito, vamos partir para a criação das paletas, que serão o que cada jogador irá controlar.\r\nEntão, vamos criar um objeto, em javascript chamado Jogador. Onde o jogador irá conter, uma posição X e Y inicial, uma pontuação, e irá precisar de uma cor para que possa se mover. Vamos criar também mais duas variáveis para que caso tamanho do monitor seja diferente as paletas (jogadores) ‘consigam se adaptar ao tamanho, e não fique desproporcional, e uma última para que possamos definir a posição Y inicial dos jogadores. Então, mãos na massa!\r\n\r\n```\r\n   var\r\n\tLARGURA  = window.innerWidth,\r\n\tALTURA = window.innerHeight,\r\n\tLARGURA_JOGADOR = LARGURA / 100,\r\n\tALTURA_JOGADOR = ALTURA / 6,\r\n\tPOS_INI_Y = (ALTURA - ALTURA_JOGADOR) / 2,\r\n\tcanvas,\r\n\tctx,\r\n \r\n\t//Criação do objeto player. Onde respectivamente os parâmetros são referentes a posição X, Y, posição X de onde ficará o valores da pontuação, e a cor para que ele possa se mover na tela.\r\n\tJogador = function(X, Y, pX, corParaMover){\r\n    \t    return {\r\n        \tx: X,\r\n        \ty: Y,\r\n        \tpontos: 0,\r\n        \tcor: corParaMover,\r\n        \tlargura:  20,\r\n        \taltura: 100,\r\n \r\n        \t//método responsável para atualizar a posição Y da paleta conforme o jogador move a cor.\r\n        \tatualizar: function() {\r\n            \t//define limites para que o meu jogador não saia dos limites da tela\r\n            \tthis.y = Math.max(Math.min(this.y, HEIGHT - this.altura), 0);\r\n        \t},\r\n        \t//método responsável por atualizar o desenho da paleta conforme o jogador move a cor.\r\n        \tdesenhar: function() {\r\n            \t//desenha a paleta com os parâmetros passados\r\n            \tctx.fillRect(this.x, this.y, this.largura, this.altura);\r\n            \t//define a fonte que será usada para escrever a pontuação do jogador\r\n            \tctx.font = \"26px Helvetica\";\r\n            \t//define o que será escrito na tela, e qual será a posição X e depois a Y\r\n            \tctx.fillText(this.pontos, pX, 20);\r\n        \t}       \t\r\n    \t    };\r\n\t};\r\n```\r\n\r\nCom nossa classe criada, coloque logo após ela a criação dos objetos, já que iremos usá-los logo:\r\n\r\n```\r\njogador1 = new Jogador(0, POS_INI_Y, LARGURA  / 2 - 35, 'magenta');\r\njogador2 = new Jogador(LARGURA - LARGURA_JOGADOR, POS_INI_Y, LARGURA  / 2 + 20, 'cyan');\r\n```\r\n\r\nPrecisamos colocar também a chamada para desenhar os jogadores no campo na nossa função “desenhar”, então para isso adicione em um local antes do “restore()”:\r\n```\r\njogador1.desenhar();\r\njogador2.desenhar();\r\n```\r\n\r\nAgora, vamos fazer os nossos jogadores se moverem, para isso, vamos começar a usar a biblioteca jasvascript “trackin.js” e colocaremos logo após nosso jogador player a seguinte chamada:\r\n\r\n```\r\n \t//pegando o elemento pelo \"id\"\r\n\tvar video = document.getElementById('video');\r\n\t//definindo a variavel para trabalhar com a realidade aumentada, e definindo as cores que a câmera irá procurar\r\n\tvar tracker = new tracking.ColorTracker([player.cor, player2.cor]);\t\r\n\t//pegando a tag \"video\" que possui o ID = video, e liga a câmera\r\n\ttracking.track('#video', tracker, {\r\n    \tcamera: true\r\n\t});\r\n\t//pegando a var. \"track\" e falando ligado a ela, o programa fará...\r\n\ttracker.on('track', function(event) {\r\n    \t//fazendo um for para cada retângulo referente as cores que a biblioteca encontrar\r\n    \tevent.data.forEach(function(rect) {\r\n        \t//se a cor for igual a cor do jogador 1 ele irá posicionar a paleta (jogador) conforme o jogador(humano) mover a cor.\r\n      \t if (rect.color === jogador1.cor)\r\n            \tjogador1.y = rect.y * 2.7;\r\n        \tif (rect.color === jogador2.cor){\r\n            \tjogador2.y = rect.y * 2.7;\r\n     \t   }\r\n    \t});\r\n\t});\r\n```\r\n\r\nNote que ele irá pedir autorização para capturar a sua câmera:\r\n\r\n![pedindo permissão (FireFox)](http://s30.postimg.org/ux6xzi5lt/pedindo_camera.png)\r\n\r\nE se tudo deu certo, o seu jogo deve estar dessa maneira:\r\n\r\n![campo com jogadores e pontuação](http://s30.postimg.org/f7r7ljysh/campo_2.png)\r\n\r\nPorém, note que mesmo que você faça os movimentos com a cor nenhuma paleta se move. Isso se deve pois a tela precisa ser “repintada”, para isso, precisamos implementar mais um trecho de código na nossa função principal (main):\r\n\r\n```\r\n    \tvar repintar = function() {\r\n        \tatualizar();\r\n        \tdesenhar();\r\n            window.requestAnimationFrame(repintar, canvas);\r\n    \t};\r\n        window.requestAnimationFrame(repintar, canvas);\r\n```\r\n \r\nAgora sim, as paletas devem estar se movendo conforme o esperado:\r\n\r\n![campo com jogadores podendo se mover](http://s30.postimg.org/cb46l9syp/campo_3.png)\r\n \r\nMas, ainda falta algo essencial, a bola! Vamos então, criar uma bola que possua o atributo diâmetro.  Vamos por enquanto apenas criar uma variável informando o diâmetro da bola, e também um método “desenhar” para que possamos enxergar se nossa bola está sendo desenhada na tela ou não, para isso digite logo após a criação dos jogadores:\r\n```\r\n\t//esse if ternário, irá servir para que se a tela do usuário for muito pequena, a bola não fique tão pequena também, facilitando a “jogabilidade” e diversão.\r\n\tDIAMETRO_BOLA = window.innerWidth / (window.innerWidth < 600 ? 30 : 70),\r\n\tBola = function(Diametro){\r\n    \treturn {\r\n        \tx: null,\r\n        \ty: null,\r\n        \tdiametro: Diametro,\r\n        \tvelocidade: null,\r\n        \tdesenhar: function() {\r\n       \t     ctx.fillRect(this.x, this.y, this.diametro, this.diametro);\r\n        \t}\r\n    \t};\r\n\t}\r\nbola = new Bola(DIAMETRO_BOLA);\r\n```\r\n\r\nE na função principal “desenhar” chame a função desenhar do objeto “bola”:\r\n\r\n```\r\nbola.desenhar();\r\n```\r\n\r\nSe tudo deu certo o nosso jogo deve estar assim:\r\n\r\n![campo com a bola](http://s30.postimg.org/t2u3hrild/campo_4.png)\r\n\r\n\r\nVamos criar um método “configuracoes” onde irá informar a posição Y que a bola irá começar, direção para que ela irá, ângulo e afins, para isso crie uma variável dentro da classe “Bola” chamada de “lado”, onde ela vai ser 1 para ir para a direita e -1 para ir para a esquerda (imagine isso como um plano cartesiano).\r\n\r\n```\r\n        \tlado: 1,\r\n        \tconfigurar: function(lado) {\r\n            \t// sorteando uma posição aleatória para criar a nossa bola para colocar na posição Y\r\n            \tvar r = Math.random();\r\n            \tthis.x = lado === 1 ? jogador1.x + jogador1.largura : jogador2.x - this.diametro;\r\n            \tthis.y = (ALTURA - this.diametro) * r;\r\n            \t// calcular o ângulo, maior ângulo / inferior no eixo-y mais íngreme\r\n            \tvar phi = 0.1 * Math.PI * (1 - 2 * r);\r\n            \t// calculando a velocidade que a bola irá se mover\r\n            \tthis.vel = {\r\n                \tx: lado * this.velocidade * Math.cos(phi),\r\n                \ty: this.velocidade * Math.sin(phi)\r\n \t           }\r\n        \t},\r\n```\r\n\r\nE na função principal (main) chame o método “configurar(1)”:\r\n\r\n```\r\nbola.configurar(1);\r\n```\r\n\r\nAgora, precisamos fazer a nossa bola se movimentar, então vamos criar mais um método “atualizar” que será responsável por isso e detectar as colisões:\r\n```\r\n        \tatualizar: function() {\r\n            \t// atualiza a posição com a velocidade atual\r\n            \tthis.x += this.vel.x;\r\n            \tthis.y += this.vel.y;\r\n            \t//checando se  sai dos limites da tela na posição Y\r\n            \tif (0 > this.y || this.y + this.diametro > ALTURA) {\r\n                \t// calculate and add the right offset, i.e. how far\r\n                \t// inside of the canvas the ball is\r\n                \tvar offset = this.vel.y < 0 ? 0 - this.y : ALTURA - (this.y + this.diametro);\r\n                \tthis.y += 2 * offset;\r\n                \t// mirror the y velocity\r\n                \tthis.vel.y *= -1;\r\n            \t}\r\n            \t// helper function to check intesectiont between two\r\n            \t// axis aligned bounding boxex (AABB)\r\n            \tvar AABBIntersect = function(ax, ay, aw, ah, bx, by, bw, bh) {\r\n                \treturn ax < bx+bw && ay < by+bh && bx < ax+aw && by < ay+ah;\r\n            \t};\r\n            \t// detectando colisão\r\n            \tvar pdle = this.vel.x < 0 ? jogador1 : jogador2;\r\n            \tif (AABBIntersect(pdle.x, pdle.y, pdle.largura, pdle.altura,\r\n                    \tthis.x, this.y, this.diametro, this.diametro)\r\n            \t) {\r\n                \t// set the x position and calculate reflection angle\r\n                \tthis.x = pdle === jogador1 ? jogador1.x + jogador1.largura : jogador2.x - this.diametro;\r\n                    var n = (this.y + this.diametro - pdle.y) / (pdle.altura + this.diametro);\r\n                \tvar phi = 0.25 * Math.PI * (2 * n - 1); // pi/4 = 45\r\n                \t// calculate smash value and update velocity\r\n                \tvar batida = Math.abs(phi) > 0.2 * Math.PI ? 1.5 : 1;\r\n                \tthis.vel.x = batida * (pdle === jogador1 ? 1 : -1) * this.velocidade * Math.cos(phi);\r\n                \tthis.vel.y = batida * this.velocidade * Math.sin(phi);\r\n            \t}\r\n            \t// coloca a bola novamente no campo na posição X que ela saiu.\r\n            \tif (0 > this.x + this.diametro || this.x > LARGURA) {\r\n                \tif (pdle === jogador1)\r\n                    \tjogador2.pontos += 1;\r\n                \telse\r\n                    \tjogador1.pontos += 1;\r\n                \tthis.configurar(pdle === jogador1 ? 1 : -1);\r\n            \t}\r\n\t        },\r\n```\r\n \r\nUfa! Faça a chamada do método “configurar” do objeto “bola” criado, e a função “atualizar” na função principal “atualizar”.\r\nA função main no final das contas estará dessa forma:\r\n```\r\n\tfunction main(){\r\n    \tcanvas = document.createElement(\"canvas\");\r\n    \tcanvas.width = LARGURA;\r\n    \tcanvas.height = ALTURA;\r\n    \tctx = canvas.getContext(\"2d\");\r\n        document.body.appendChild(canvas);\r\n    \tbola.configurar(1);\r\n    \tvar repintar = function() {\r\n        \tatualizar();\r\n        \tdesenhar();\r\n            window.requestAnimationFrame(repintar, canvas);\r\n    \t};\r\n        window.requestAnimationFrame(repintar, canvas);\r\n\t}\r\n```\r\n\r\nE a função atualizar estará assim:\r\n\r\n```\r\n\tfunction atualizar() {\r\n    \tbola.atualizar();\r\n    \tjogador1.atualizar();\r\n    \tjogador2.atualizar();\r\n\t}\r\n```\r\n\r\nPronto! O resultado esperado do game deve ser semelhante a esse:\r\n\r\n![jogo completo](http://s30.postimg.org/exoafy9k1/campo_5.png)\r\n\r\n###Referência:\r\nhttps://github.com/maxwihlborg/youtube-tutorials/blob/master/pong/index.html\r\nhttp://trackingjs.com/docs.html#introduction","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}